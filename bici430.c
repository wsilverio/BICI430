/*

    Projeto BICI430
    registrador de dados para bicicletas, integrado a um celular móvel

    A fazer:
        - formatação do tempo: hh:mm:ss
    - receber a string de notificação pela serial
*/

#include <msp430.h>
#include <string.h>

/* protótipo das funções */

// configura comunicação SPI
void config_USIB();
// configura o LCD
void LCDNokia_config();
// escreve um byte (comando ou caractere) no LCD
void LCDNokia_write_byte(char bin, char dc);
// escreve um ASCII no LCD
void LCDNokia_write_char(char dado);
// escreve uma string no LCD
void LCDNokia_write_str(char *caracter);
// apaga ou preenche todos os px do LCD (fill: WHITE ou BLACK)
void LCDNokia_clear(char fill);
// posiciona o cursor (x: 0-13, y: 0-6)
void LCDNokia_poscursor(char x, char y);

// configura a serial UART 9600 bps
void Serial_config(void);
// escreve um byte na serial
void Serial_escreve_dado(char dado);
// escreve uma string na serial
void Serial_escreve_texto(char *caracter);
// converte um numero inteiro para string
void itoa(long unsigned int inteiro, char* string);
// converte um numero flutuante para string
void ftoa(float n, char *res, int casas);
// funcao de potencia
float _pow(float base, float expoente);
// delay em ms
void delay_ms(unsigned int ms);
// exibe uma imagem no LCD
void print_notificacao(char notificacao);


/* definição das constantes */

// menu
#define NOTIFICACAO 0
#define DATA_LOGGER 1

// bicicleta
#define R 0.45
#define PI 3.1416
#define CIRC 1000.0 * 2 * PI * R // 1000: dt -> ms

// periféricos
#define BOTAO BIT3 // botao conectado ao pino P1.3
#define SENSOR BIT4 // sensor conectado ao P1.4
#define LED0 BIT0 // led vermelho conectado ao P1.0
#define LED1 BIT6 // led verde conectado ao P1.6
#define RX_pin BIT1 // pino de recepção serial P1.1
#define TX_pin BIT2 // pino de transmissão serialP1.2

// display
#define RST  BIT0 // P2.0 RESET | borda negativa
#define SCE  BIT1 // P2.1 Chip Enable | Borda de subida: fim do trem de pulso | Borda de descida: habilita serial e indica inicio da transmissao
#define DC   BIT2 // P2.2 Mode Select | lido no ultimo bit | 0: cmd, 1: RAM data e ADDR++
#define SDIN BIT7 // P1.7 Serial Data Line | dado serial | lido na borda de subida SCLK
#define SCLK BIT5 // P1.5 Serial Clock Line
// funcao LCDNokia_write_byte()
#define CMD 0
#define TXT 1
// funcao LCDNokia_clear()
#define WHITE 0
#define BLACK 0xFF // 8 px

#define LCDNokia_width 84
#define LCDNokia_height 48

// caracteres ASCII
static const char font[][5] = {
     {0x00, 0x00, 0x00, 0x00, 0x00} // 20  
    ,{0x00, 0x00, 0x5f, 0x00, 0x00} // 21 !
    ,{0x00, 0x07, 0x00, 0x07, 0x00} // 22 "
    ,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 23 #
    ,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 24 $
    ,{0x23, 0x13, 0x08, 0x64, 0x62} // 25 %
    ,{0x36, 0x49, 0x55, 0x22, 0x50} // 26 &
    ,{0x00, 0x05, 0x03, 0x00, 0x00} // 27 '
    ,{0x00, 0x1c, 0x22, 0x41, 0x00} // 28 (
    ,{0x00, 0x41, 0x22, 0x1c, 0x00} // 29 )
    ,{0x14, 0x08, 0x3e, 0x08, 0x14} // 2a *
    ,{0x08, 0x08, 0x3e, 0x08, 0x08} // 2b +
    ,{0x00, 0x50, 0x30, 0x00, 0x00} // 2c ,
    ,{0x08, 0x08, 0x08, 0x08, 0x08} // 2d -
    ,{0x00, 0x60, 0x60, 0x00, 0x00} // 2e .
    ,{0x20, 0x10, 0x08, 0x04, 0x02} // 2f /
    ,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 30 0
    ,{0x00, 0x42, 0x7f, 0x40, 0x00} // 31 1
    ,{0x42, 0x61, 0x51, 0x49, 0x46} // 32 2
    ,{0x21, 0x41, 0x45, 0x4b, 0x31} // 33 3
    ,{0x18, 0x14, 0x12, 0x7f, 0x10} // 34 4
    ,{0x27, 0x45, 0x45, 0x45, 0x39} // 35 5
    ,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 36 6
    ,{0x01, 0x71, 0x09, 0x05, 0x03} // 37 7
    ,{0x36, 0x49, 0x49, 0x49, 0x36} // 38 8
    ,{0x06, 0x49, 0x49, 0x29, 0x1e} // 39 9
    ,{0x00, 0x6C, 0x6C, 0x00, 0x00} // 3a :
    ,{0x00, 0x56, 0x36, 0x00, 0x00} // 3b ;
    ,{0x08, 0x14, 0x22, 0x41, 0x00} // 3c <
    ,{0x14, 0x14, 0x14, 0x14, 0x14} // 3d =
    ,{0x00, 0x41, 0x22, 0x14, 0x08} // 3e >
    ,{0x02, 0x01, 0x51, 0x09, 0x06} // 3f ?
    ,{0x32, 0x49, 0x79, 0x41, 0x3e} // 40 @
    ,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 41 A
    ,{0x7f, 0x49, 0x49, 0x49, 0x36} // 42 B
    ,{0x3e, 0x41, 0x41, 0x41, 0x22} // 43 C
    ,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 44 D
    ,{0x7f, 0x49, 0x49, 0x49, 0x41} // 45 E
    ,{0x7f, 0x09, 0x09, 0x09, 0x01} // 46 F
    ,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 47 G
    ,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 48 H
    ,{0x00, 0x41, 0x7f, 0x41, 0x00} // 49 I
    ,{0x20, 0x40, 0x41, 0x3f, 0x01} // 4a J
    ,{0x7f, 0x08, 0x14, 0x22, 0x41} // 4b K
    ,{0x7f, 0x40, 0x40, 0x40, 0x40} // 4c L
    ,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 4d M
    ,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 4e N
    ,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 4f O
    ,{0x7f, 0x09, 0x09, 0x09, 0x06} // 50 P
    ,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 51 Q
    ,{0x7f, 0x09, 0x19, 0x29, 0x46} // 52 R
    ,{0x46, 0x49, 0x49, 0x49, 0x31} // 53 S
    ,{0x01, 0x01, 0x7f, 0x01, 0x01} // 54 T
    ,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 55 U
    ,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 56 V
    ,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 57 W
    ,{0x63, 0x14, 0x08, 0x14, 0x63} // 58 X
    ,{0x07, 0x08, 0x70, 0x08, 0x07} // 59 Y
    ,{0x61, 0x51, 0x49, 0x45, 0x43} // 5a Z
    ,{0x00, 0x7f, 0x41, 0x41, 0x00} // 5b [
    ,{0x02, 0x04, 0x08, 0x10, 0x20} // 5c ¥
    ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 5d ]
    ,{0x04, 0x02, 0x01, 0x02, 0x04} // 5e ^
    ,{0x40, 0x40, 0x40, 0x40, 0x40} // 5f _
    ,{0x00, 0x01, 0x02, 0x04, 0x00} // 60 `
    ,{0x20, 0x54, 0x54, 0x54, 0x78} // 61 a
    ,{0x7f, 0x48, 0x44, 0x44, 0x38} // 62 b
    ,{0x38, 0x44, 0x44, 0x44, 0x20} // 63 c
    ,{0x38, 0x44, 0x44, 0x48, 0x7f} // 64 d
    ,{0x38, 0x54, 0x54, 0x54, 0x18} // 65 e
    ,{0x08, 0x7e, 0x09, 0x01, 0x02} // 66 f
    ,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 67 g
    ,{0x7f, 0x08, 0x04, 0x04, 0x78} // 68 h
    ,{0x00, 0x44, 0x7d, 0x40, 0x00} // 69 i
    ,{0x20, 0x40, 0x44, 0x3d, 0x00} // 6a j 
    ,{0x7f, 0x10, 0x28, 0x44, 0x00} // 6b k
    ,{0x00, 0x41, 0x7f, 0x40, 0x00} // 6c l
    ,{0x7c, 0x04, 0x18, 0x04, 0x78} // 6d m
    ,{0x7c, 0x08, 0x04, 0x04, 0x78} // 6e n
    ,{0x38, 0x44, 0x44, 0x44, 0x38} // 6f o
    ,{0x7c, 0x14, 0x14, 0x14, 0x08} // 70 p
    ,{0x08, 0x14, 0x14, 0x18, 0x7c} // 71 q
    ,{0x7c, 0x08, 0x04, 0x04, 0x08} // 72 r
    ,{0x48, 0x54, 0x54, 0x54, 0x20} // 73 s
    ,{0x04, 0x3f, 0x44, 0x40, 0x20} // 74 t
    ,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 75 u
    ,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 76 v
    ,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 77 w
    ,{0x44, 0x28, 0x10, 0x28, 0x44} // 78 x
    ,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 79 y
    ,{0x44, 0x64, 0x54, 0x4c, 0x44} // 7a z
    ,{0x00, 0x08, 0x36, 0x41, 0x00} // 7b {
    ,{0x00, 0x00, 0x7f, 0x00, 0x00} // 7c |
    ,{0x00, 0x41, 0x36, 0x08, 0x00} // 7d }
    ,{0x10, 0x08, 0x08, 0x10, 0x08} // 7e ←
    ,{0x00, 0x06, 0x09, 0x09, 0x06} // 7f →
};

/* definição das variáveis */
float vel = 0; // velocidade instantânea
unsigned int voltas = 0; // número de voltas da roda; reset em 65535 ~= 185km
unsigned int dt = 0; // intervalo de tempo 'dt'; reset em ~= 65s
unsigned long tempo = 0; // tempo percorrido em ms; reset em ~= 50 dias
unsigned char timeout = 0; // timeout para a velocidade, expira em 3s

//unsigned char LCDNokia_col = 0; // x
//unsigned char LCDNokia_row = 0; // y

// variáveis de menu
unsigned char menu = DATA_LOGGER;
unsigned char pausa = 1;

char valor_str[10]; // string de uso geral

// ícones
static const char chamada[504] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x07, 0x0F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x1F, 0x1F, 0x0F, 0x07, 0x07, 0x0F, 0x0F, 0x1F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const char sms[504] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x1F, 0x0F, 0x0F, 0x0F, 0x0F, 0x1F, 0x1F, 0x3F, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x71, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0xFF, 0xF8, 0x60, 0x40, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x40, 0x60, 0xF8, 0xFF, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xC1, 0xC0, 0x80, 0x80, 0x80, 0x80, 0x80, 0xE0, 0x0C, 0x06, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0x0C, 0xE0, 0x80, 0x80, 0x80, 0x80, 0x80, 0xC0, 0xC1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 0xFE, 0xFC, 0xFC, 0xFC, 0x78, 0x78, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0x78, 0x78, 0xFC, 0xFC, 0xFC, 0xFE, 0xFF, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xE1, 0xC0, 0xC0, 0xCE, 0x8E, 0x8C, 0x1C, 0x3F, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0xF0, 0x80, 0x0F, 0x7F, 0x3F, 0x07, 0xC0, 0xF0, 0x00, 0x00, 0x7F, 0xFF, 0xF3, 0xE0, 0xC0, 0xC4, 0xCE, 0x8E, 0x1C, 0x1C, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xF9, 0xF1, 0xF3, 0xF3, 0xF3, 0xF1, 0xF0, 0xF8, 0xFF, 0xFF, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFC, 0xF0, 0xF0, 0xFC, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xFF, 0xFF, 0xF1, 0xF3, 0xF3, 0xF3, 0xF3, 0xF0, 0xF8, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const char mail[504] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x41, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0xC1, 0x41, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0xF8, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x81, 0x83, 0x03, 0x07, 0x07, 0x0F, 0x1F, 0x1F, 0x0F, 0x07, 0x07, 0x03, 0x83, 0x81, 0xC0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE, 0xFC, 0xFC, 0xFC, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC0, 0x80, 0x80, 0x80, 0x80, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x83, 0x80, 0x80, 0x80, 0x80, 0xC0, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const char facebook[504] = {0xE0, 0xF0, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF8, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x1F, 0x1F, 0x1F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

unsigned char notif_receive = 0; // indicador de "pronto para nova notificação"

void main(void){
      
    // desativa watchdog timer
    WDTCTL = WDTPW + WDTHOLD;
  
    // configura o clock @8MHz
    BCSCTL1 = CALBC1_8MHZ;
    DCOCTL = CALDCO_8MHZ;

    // configura as saídas do P2
    P2DIR = RST + SCE + DC;
    // configura as saídas do P1
    P1DIR = LED0 + LED1;

    // habilita o resistor
    P1REN = SENSOR + BOTAO;
    // ativa o resistor
    P1OUT = SENSOR + BOTAO;
    
    // configura a interrupção por borda de descida
    P1IE = P1IES = SENSOR + BOTAO;
    
    // limpa as interrupções do P1
    P1IFG = 0;
    
    // configura o timer A0
    TA0CTL = TASSEL_2 + ID_3 + MC_1; // smclk, div 8, up CCR0
    TACCTL0 |= CCIE; // interrupção por comparação
    TACCR0 = 1000; // @8MHz -> 1ms

    // configura a comunicação serial uart
    // 9600 bps, 8 bits, sem paridade
    Serial_config();
    // configura a SPI
    config_USIB();
    // configura o LCD
    LCDNokia_config();

    LCDNokia_poscursor(0, 2);
    LCDNokia_write_str("   BICI 430");
    LCDNokia_poscursor(1, 3);
    LCDNokia_write_str("PRESS START");
    
    // aguarda a intereção do usuario
    while(P1IN & BOTAO);

    // limpa o display
    LCDNokia_clear(WHITE);

    // habilita as interrupções
    __enable_interrupt();
    
    // solicita nova notificação
    Serial_escreve_dado('1');
    
    while(1){ // loop
        if (menu == NOTIFICACAO){
            // ...
        }else if (menu == DATA_LOGGER && !pausa){
            
            if(timeout > 3){
                // zera a velocidade após 3s se não houver leitura do sensor
                vel = timeout = 0;
            }
            
            LCDNokia_clear(WHITE);
            LCDNokia_write_str("   BICI 430");
            
            // cálculo da velocidade média
            float vel_med = CIRC * (voltas)/tempo;
        
            // velocidade instantânea
            LCDNokia_poscursor(0, 2);
            LCDNokia_write_str("vel:");
            ftoa(vel, valor_str, 2);
            LCDNokia_write_str(valor_str);
            LCDNokia_write_str("m/s");
            // velocidade média
            LCDNokia_poscursor(0, 3);
            LCDNokia_write_str("vmed:");
            ftoa(vel_med, valor_str, 2);
            LCDNokia_write_str(valor_str);
            LCDNokia_write_str("m/s");

            // envia pela UART o valor da distância percorrida (em m)
            LCDNokia_poscursor(0, 4);
            LCDNokia_write_str("dist:");
            ftoa(CIRC * voltas / 1000.0, valor_str, 2);
            LCDNokia_write_str(valor_str);
            LCDNokia_write_str("m");
        
            // tempo percorrido (em s)
            LCDNokia_poscursor(0, 5);
            LCDNokia_write_str("tempo:");
            itoa(tempo/1000, valor_str);
            LCDNokia_write_str(valor_str);
            LCDNokia_write_str("s");
            
            // aguarda 1s
            delay_ms(1000);            
        }
    }
}

#pragma vector = PORT1_VECTOR
__interrupt void int_P1(void){
//__attribute__((interrupt(PORT1_VECTOR)))
//void int_P1(void){

    // interrupção do sensor
    if(P1IFG & SENSOR && !pausa){
        // cálculo da velocidade instantânea
        vel = CIRC/dt;
        dt = 0;
        voltas++;
        timeout = 0;

        // debouncing
        //__delay_cycles(8000); // 1ms
        //while(!(P1IN & SENSOR));
        //__delay_cycles(8000);
                
        // limpa flag de interrupção do sensor
        P1IFG &= ~SENSOR;

    }else if(P1IFG & BOTAO){ // interrupção do botao

        if (menu == DATA_LOGGER){
            // inverte a 'pausa' e o led indicador
            P1OUT = (pausa = !pausa)?(P1OUT & ~LED1):(P1OUT | LED1);

        }else if(menu == NOTIFICACAO){
            // limpa a notificacao
            menu = DATA_LOGGER;
            // apaga o led
            P1OUT &= ~LED0;
            // solicita nova notificação
            Serial_escreve_dado('1');
        }

        // debouncing
        __delay_cycles(8000); // 1ms
        while(!(P1IN & BOTAO));
        __delay_cycles(8000);

        // limpa flag int. botao
        P1IFG &= ~BOTAO;
    }
}

#pragma vector = TIMER0_A0_VECTOR
__interrupt void int_timer_A(void){
//__attribute__((interrupt(TIMER0_A0_VECTOR)))
//void int_timer_A(void){

    if(!pausa){
        // atualiza as variáveis
        dt++;
        tempo++;
        
        // incrementa timeout a cada 1s
        if(!(tempo % 1000)) timeout++;
    }

    // limpa flag de imterrupção do timer A0
    TACCTL0 &= ~CCIFG;
}

#pragma vector = USCIAB0RX_VECTOR
__interrupt void Serial_receive(void){
//__attribute__((interrupt(USCIAB0RX_VECTOR)))
//void Serial_receive(void){
    // lê o dado recebido e aciona o display
    print_notificacao(UCA0RXBUF);
}

void Serial_config(void){
    // ativa as funções UART nos pinos
    P1SEL |= (RX_pin + TX_pin);
    P1SEL2 |= (RX_pin + TX_pin);
    // USCI reset: desabilitado para operacao
    UCA0CTL1 |= UCSWRST;
    // modo UART assíncrono
    UCA0CTL0 &= ~(UCMODE1 + UCMODE0 + UCSYNC);
    // USCI clock: modo 2 (SMCLK)
    UCA0CTL1 |= UCSSEL_2;
    // Oversampling desabilitado
    UCA0MCTL &= ~UCOS16;
    // configura baud rate para 9600 bps
    UCA0BR1 = 0x03;
    UCA0BR0 = 0x41;
    UCA0MCTL |= 0x06;
    // USCI reset: liberado para operação
    UCA0CTL1 &= ~UCSWRST;
    // habilita interrupção de recepção
    IE2 |= UCA0RXIE;
}

void Serial_escreve_dado(char dado){
    // aguarda buffer vazio
    while(!(IFG2 & UCA0TXIFG));
    // escreve o dado
    UCA0TXBUF = dado;
}

void config_USIB(){
    // configura os pinos USIB
    P1SEL |= SCLK + SDIN;
    P1SEL2 |= SCLK + SDIN;
    // reset
    UCB0CTL1 |= UCSWRST;
    // Data capture, MSB, Master, 3-pin SPI, sinc
    UCB0CTL0 |= UCCKPH + UCMSB + UCMST + UCMODE_0 + UCSYNC;
    // SMCLK
    UCB0CTL1 |= UCSSEL_2;
    // Clock
    UCB0BR0 = 1; // 8MHz / 1
    UCB0BR1 = 0;
    // SPI habilitada
    UCB0CTL1 &= ~UCSWRST;
    // limpa flag
    IFG2 &= ~UCB0TXIFG;
}

void LCDNokia_config(){
    // pulso de reset
    P2OUT &= ~RST;
    delay_ms(50);
    P2OUT |= RST;
    // inicialização
    LCDNokia_write_byte(0x21, CMD); // instrucoes extendidas
    LCDNokia_write_byte(0xB1, CMD); // contraste
    LCDNokia_write_byte(0x04, CMD); // coef temperatura
    LCDNokia_write_byte(0x14, CMD); // bias modo 1:48
    LCDNokia_write_byte(0x20, CMD); // retorna para os comandos básicos
    LCDNokia_write_byte(0x0C, CMD); // modo normal
    // limpa o display
    LCDNokia_clear(WHITE);
}

void LCDNokia_write_byte(char bin, char dc){
    // CMD ou TXT
    P2OUT = (dc)?(P2OUT | DC):(P2OUT & ~DC);
    // Seleciona o display (inicio da transmissao)
    P2OUT &= ~SCE;
    // Envia o byte SPI
    UCB0TXBUF = bin;
    // Aguarda buffer vazio
    while(!(IFG2 & UCB0TXIFG));
    // fim da transmissao
    P2OUT |= SCE;
}

void LCDNokia_write_char(char dado){
    // escreve o ASCII
    for(int i = 0; i < 5; i++){
        LCDNokia_write_byte(font[dado - 0x20][i], TXT);
    }
    // coluna vazia (espaçamento)
    LCDNokia_write_byte(0x00, TXT);
}

void LCDNokia_write_str(char *caracter){
    // percorre a string byte-a-byte
    while(*caracter){
        LCDNokia_write_char(*caracter);
        caracter++;
    }
}

void LCDNokia_clear(char fill){
    // preenche todos os px com 0 ou 0xFF
    for (int i = 0; i < 504; i++){
        LCDNokia_write_byte(fill, TXT);
    }
    // volta o cursor ao inicio
    LCDNokia_poscursor(0, 0);
}

void LCDNokia_poscursor(char x, char y){
    LCDNokia_write_byte(0x80 + x*6, CMD);
    LCDNokia_write_byte(0x40+y, CMD);
}

void itoa(long unsigned int inteiro, char* string){
    // baseada em http://www.strudel.org.uk/itoa/
    
    char* ptr = string, *ptr1 = string, tmp_char;
    int tmp_inteiro;

    do{
        tmp_inteiro = inteiro;
        inteiro /= 10;
        *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz" [35 + (tmp_inteiro - inteiro * 10)];
    }while(inteiro);
    
    if(tmp_inteiro < 0) *ptr++ = '-';
    
    *ptr-- = '\0';
    
    while(ptr1 < ptr){
        tmp_char = *ptr;
        *ptr--= *ptr1;
        *ptr1++ = tmp_char;
    }
}

void ftoa(float n, char *res, int casas){
    // baseada em http://www.geeksforgeeks.org/convert-floating-point-number-string/
    // parte inteira do número
    int iparte = (int) n;
    // parte flutuante (após a vírgula)
    float fparte = n - (float) iparte;
    // carrega a parte inteira na string
    itoa(iparte, res);
    if (casas != 0){
        // adiciona o 'ponto'
        strcat(res, ".");
        // tranforma a parte flutuante
        fparte = fparte * _pow(10, casas);
        // concatena a parte flutuante à parte inteira
        itoa((int)fparte, res + strlen(res));
    }
}

float _pow(float base, float expoente){
    float n = base;
    while(--expoente) n *= base;
    return n;
}

void delay_ms(unsigned int ms) {
    while (ms--) {
        __delay_cycles(8000);
    }
}

void print_notificacao(char notificacao){   

    menu = NOTIFICACAO;

    LCDNokia_clear(WHITE);
    
    P1OUT |= LED0;

    switch(notificacao){
        case 1: // icone de chamada
        {                
            for (int i = 0; i < 504; i++)
                LCDNokia_write_byte(chamada[i], TXT);
            
            LCDNokia_poscursor(8, 3);
            LCDNokia_write_str("Marco");
        }break;

        case 2: // icone sms
        {
            for (int i = 0; i < 504; i++)
                LCDNokia_write_byte(sms[i], TXT);
            
            LCDNokia_poscursor(9, 3);
            LCDNokia_write_str("TIM");
         }break;

        case 3: // icone de email   
        {          
            for (int i = 0; i < 504; i++)
                LCDNokia_write_byte(mail[i], TXT);
            
            LCDNokia_poscursor(8, 3);
            LCDNokia_write_str("Malu");
        }break;

        case 4: // icone facebook
        {
            for (int i = 0; i < 504; i++)
                LCDNokia_write_byte(facebook[i], TXT);
            
            LCDNokia_poscursor(8, 3);
            LCDNokia_write_str("Pedro");
         }break;

        default: // retorna ao menu de dados
        {
            menu = DATA_LOGGER;
        }break;
    }
}
